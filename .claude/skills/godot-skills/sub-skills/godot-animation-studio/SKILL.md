---
name: godot-animation-studio
description: Godot èµ„æºä¸åŠ¨ç”»åˆ›å»ºä¸“å®¶ï¼Œæ”¯æŒè‡ªç„¶è¯­è¨€æè¿°è‡ªåŠ¨å®Œæˆç²¾çµå¯¼å…¥ã€åŠ¨ç”»é…ç½®ã€ç‰¹æ•ˆåˆ¶ä½œã€éŸ³æ•ˆé›†æˆç­‰èµ„æºå·¥ä½œ
---

# Godot åŠ¨ç”»å·¥ä½œå®¤ä¸“å®¶æŠ€èƒ½

> **é‡è¦æç¤º**: æœ¬æŠ€èƒ½çš„æ‰€æœ‰ä»£ç ç¤ºä¾‹å‡åŸºäº **Godot 4.5** æœ€ä½³å®è·µï¼Œä½¿ç”¨ GDScript è¯­æ³•ã€‚
> ç¡®ä¿åœ¨ Godot 4.x ç¯å¢ƒä¸­ä½¿ç”¨ï¼Œæ³¨æ„ AnimationPlayer å’Œ Tween ç³»ç»Ÿçš„æ–° API å˜åŒ–ã€‚

## æŠ€èƒ½æ¦‚è¿°

`godot-animation-studio` æ˜¯ä¸“é—¨ç”¨äº Godot æ¸¸æˆèµ„æºåˆ›å»ºå’ŒåŠ¨ç”»åˆ¶ä½œçš„æ™ºèƒ½åŒ–æŠ€èƒ½ï¼Œèƒ½å¤Ÿæ ¹æ®ç”¨æˆ·çš„è‡ªç„¶è¯­è¨€æè¿°è‡ªåŠ¨å®Œæˆç²¾çµå¯¼å…¥ä¸åˆ‡ç‰‡ã€åŠ¨ç”»é…ç½®ä¸ä¼˜åŒ–ã€ç²’å­ç‰¹æ•ˆåˆ¶ä½œã€éŸ³æ•ˆé›†æˆã€èµ„æºç®¡ç†ç­‰å®Œæ•´èµ„æºåˆ¶ä½œæµç¨‹ã€‚

## æ ¸å¿ƒåŠŸèƒ½

### ğŸ¨ ç²¾çµèµ„æºç®¡ç†
- **æ™ºèƒ½å¯¼å…¥**ï¼šè‡ªåŠ¨å¯¼å…¥å’Œé…ç½®ç²¾çµå›¾é›†
- **åˆ‡ç‰‡ä¼˜åŒ–**ï¼šæ™ºèƒ½ç²¾çµåˆ‡ç‰‡å’Œç½‘æ ¼å¸ƒå±€
- **æ ¼å¼è½¬æ¢**ï¼šæ”¯æŒå¤šç§å›¾ç‰‡æ ¼å¼è½¬æ¢å’Œä¼˜åŒ–
- **æ‰¹é‡å¤„ç†**ï¼šæ‰¹é‡å¯¼å…¥å’Œå¤„ç†å¤§é‡ç²¾çµèµ„æº

### ğŸ¬ åŠ¨ç”»ç³»ç»Ÿåˆ¶ä½œ
- **AnimationPlayeré…ç½®**ï¼šåˆ›å»ºå’Œé…ç½®åŠ¨ç”»æ’­æ”¾å™¨
- **AnimationTreeçŠ¶æ€æœº**ï¼šå¤æ‚çš„åŠ¨ç”»çŠ¶æ€æœºè®¾è®¡
- **éª¨éª¼åŠ¨ç”»**ï¼š2Déª¨éª¼åŠ¨ç”»å’Œè’™çš®ç³»ç»Ÿ
- **åŠ¨ç”»æ··åˆ**ï¼šæµç•…çš„åŠ¨ç”»è¿‡æ¸¡å’Œæ··åˆ

### âœ¨ ç²’å­ç‰¹æ•ˆåˆ¶ä½œ
- **GPUParticles2D/3D**ï¼šGPUç²’å­ç³»ç»Ÿé…ç½®
- **CPUParticles2D/3D**ï¼šCPUç²’å­ç³»ç»Ÿä¼˜åŒ–
- **ç²’å­æè´¨**ï¼šè‡ªå®šä¹‰ç²’å­ç€è‰²å™¨å’Œæè´¨
- **ç‰¹æ•ˆç»„åˆ**ï¼šå¤æ‚ç‰¹æ•ˆçš„ç»„åˆå’Œå±‚çº§ç®¡ç†

### ğŸµ éŸ³æ•ˆèµ„æºé›†æˆ
- **éŸ³é¢‘å¯¼å…¥**ï¼šå¤šç§éŸ³é¢‘æ ¼å¼çš„å¯¼å…¥å’Œä¼˜åŒ–
- **éŸ³æ•ˆç®¡ç†**ï¼šéŸ³æ•ˆåº“çš„åˆ†ç±»å’Œç®¡ç†
- **3DéŸ³æ•ˆ**ï¼šç©ºé—´éŸ³æ•ˆå’ŒéŸ³é¢‘å¬è€…è®¾ç½®
- **åŠ¨æ€éŸ³æ•ˆ**ï¼šç¨‹åºåŒ–éŸ³æ•ˆç”Ÿæˆå’Œè°ƒåˆ¶

## ä½¿ç”¨æ–¹æ³•

### è§’è‰²åŠ¨ç”»åˆ¶ä½œ
```
ç”¨æˆ·: "æˆ‘éœ€è¦ä¸ºä¸€ä¸ªéª‘å£«è§’è‰²åˆ¶ä½œå¾…æœºã€è¡Œèµ°ã€æ”»å‡»ã€å—ä¼¤å››ç§åŠ¨ç”»"
ç³»ç»Ÿ: è‡ªåŠ¨å®ç°ï¼š
- å¯¼å…¥éª‘å£«ç²¾çµå›¾é›†
- æ™ºèƒ½åˆ‡ç‰‡å’Œå‘½åè§„èŒƒ
- åˆ›å»ºAnimationPlayerå’ŒåŠ¨ç”»è½¨é“
- é…ç½®åŠ¨ç”»æ—¶é•¿å’Œè¿‡æ¸¡
- åˆ›å»ºAnimationTreeçŠ¶æ€æœº
- æ·»åŠ åŠ¨ç”»äº‹ä»¶å’Œå›è°ƒ
```

### ç²’å­ç‰¹æ•ˆåˆ¶ä½œ
```
ç”¨æˆ·: "åˆ›å»ºä¸€ä¸ªç«ç„°çˆ†ç‚¸ç‰¹æ•ˆï¼ŒåŒ…å«ç«èŠ±ã€çƒŸé›¾å’Œå†²å‡»æ³¢"
ç³»ç»Ÿ: æ™ºèƒ½ç”Ÿæˆï¼š
- GPUParticles2Dç«ç„°ç²’å­ç³»ç»Ÿ
- çƒŸé›¾ç²’å­é…ç½®
- å†²å‡»æ³¢æ‰©æ•£æ•ˆæœ
- ç²’å­æè´¨å’Œç€è‰²å™¨
- å¤šå±‚çº§ç‰¹æ•ˆç»„åˆ
- éŸ³æ•ˆåŒæ­¥é›†æˆ
```

### UIåŠ¨ç”»åˆ¶ä½œ
```
ç”¨æˆ·: "ä¸ºæŒ‰é’®åˆ¶ä½œæ‚¬åœã€ç‚¹å‡»ã€ç¦ç”¨ä¸‰ç§çŠ¶æ€çš„åŠ¨ç”»"
ç³»ç»Ÿ: å…¨é¢å¼€å‘ï¼š
- æŒ‰é’®ç²¾çµçŠ¶æ€å¯¼å…¥
- æ‚¬åœç¼©æ”¾åŠ¨ç”»
- ç‚¹å‡»å¼¹è·³æ•ˆæœ
- ç¦ç”¨æ·¡å‡ºæ•ˆæœ
- å¹³æ»‘è¿‡æ¸¡é…ç½®
- éŸ³æ•ˆé›†æˆ
```

### ç¯å¢ƒåŠ¨ç”»åˆ¶ä½œ
```
ç”¨æˆ·: "åˆ¶ä½œä¸€ä¸ªåŠ¨æ€çš„æ£®æ—åœºæ™¯ï¼ŒåŒ…å«æ‘‡æ›³çš„æ ‘æœ¨å’Œé£˜è½çš„å¶å­"
ç³»ç»Ÿ: å®Œæ•´å®ç°ï¼š
- æ ‘æœ¨æ‘‡æ‘†åŠ¨ç”»
- å¶å­é£˜è½ç²’å­
- é£åŠ›æ–¹å‘å˜åŒ–
- åŠ¨æ€å…‰ç…§æ•ˆæœ
- ç¯å¢ƒéŸ³æ•ˆé›†æˆ
```

## å·¥ä½œæµç¨‹

### 1. èµ„æºåˆ†æ
```bash
# åˆ†æèµ„æºéœ€æ±‚
- è¯†åˆ«åŠ¨ç”»ç±»å‹å’Œå¤æ‚åº¦
- ç¡®å®šèµ„æºæ ¼å¼å’Œè§„æ ¼
- è¯„ä¼°åˆ¶ä½œæ—¶é—´å’ŒæŠ€æœ¯è¦æ±‚
```

### 2. èµ„æºå‡†å¤‡
```bash
# å‡†å¤‡èµ„æºç´ æ
- å¯¼å…¥å’Œä¼˜åŒ–å›¾ç‰‡èµ„æº
- å¤„ç†éŸ³é¢‘æ–‡ä»¶
- åˆ›å»ºåŸºç¡€æè´¨å’Œç€è‰²å™¨
```

### 3. åŠ¨ç”»åˆ¶ä½œ
```bash
# åˆ¶ä½œåŠ¨ç”»å†…å®¹
- åˆ›å»ºåŠ¨ç”»æ—¶é—´è½´
- è®¾ç½®å…³é”®å¸§å’Œæ›²çº¿
- é…ç½®åŠ¨ç”»è¿‡æ¸¡å’Œæ··åˆ
```

### 4. é›†æˆæµ‹è¯•
```bash
# æµ‹è¯•å’Œä¼˜åŒ–
- è¿è¡Œæ—¶æ€§èƒ½æµ‹è¯•
- è§†è§‰æ•ˆæœè°ƒæ•´
- éŸ³ç”»åŒæ­¥éªŒè¯
```

## MCP å·¥å…·é›†æˆ

### èµ„æºç®¡ç†å·¥å…·
- `import_asset` - å¯¼å…¥èµ„æºæ–‡ä»¶
- `create_resource` - åˆ›å»ºåŠ¨ç”»å’Œç‰¹æ•ˆèµ„æº
- `configure_resource` - é…ç½®èµ„æºå±æ€§
- `optimize_asset` - ä¼˜åŒ–èµ„æºå¤§å°å’Œè´¨é‡

### åŠ¨ç”»å·¥å…·
- `create_animation_player` - åˆ›å»ºåŠ¨ç”»æ’­æ”¾å™¨
- `create_animation_tree` - åˆ›å»ºåŠ¨ç”»çŠ¶æ€æœº
- `add_animation_track` - æ·»åŠ åŠ¨ç”»è½¨é“
- `set_animation_key` - è®¾ç½®åŠ¨ç”»å…³é”®å¸§

### ç²’å­ç³»ç»Ÿå·¥å…·
- `create_particles` - åˆ›å»ºç²’å­ç³»ç»Ÿ
- `configure_particles` - é…ç½®ç²’å­å‚æ•°
- `create_particle_material` - åˆ›å»ºç²’å­æè´¨
- `add_particle_emitter` - æ·»åŠ ç²’å­å‘å°„å™¨

### éŸ³é¢‘å·¥å…·
- `import_audio` - å¯¼å…¥éŸ³é¢‘æ–‡ä»¶
- `create_audio_stream` - åˆ›å»ºéŸ³é¢‘æµ
- `configure_audio_bus` - é…ç½®éŸ³é¢‘æ€»çº¿
- `set_3d_audio` - è®¾ç½®3DéŸ³é¢‘æ•ˆæœ

## åŠ¨ç”»åˆ¶ä½œç³»ç»Ÿ

### 2Dè§’è‰²åŠ¨ç”»
```gdscript
# æ™ºèƒ½è§’è‰²åŠ¨ç”»ç”Ÿæˆå™¨
class_name CharacterAnimationGenerator extends Node
@export var character_name: String
@export var animation_types: Array[String] = ["idle", "walk", "run", "jump", "attack", "hurt"]

func generate_character_animations(sprite_sheet: Texture2D) -> Dictionary:
    var animations = {}
    var frame_size = Vector2(64, 64)

    # è‡ªåŠ¨åˆ‡ç‰‡ç²¾çµå›¾é›†
    var sprite_frames = SpriteFrames.new()
    _slice_sprite_sheet(sprite_sheet, frame_size, sprite_frames)

    # ä¸ºæ¯ç§åŠ¨ç”»ç±»å‹åˆ›å»ºAnimationPlayerèµ„æº
    for anim_type in animation_types:
        var animation = Animation.new()
        _create_character_animation(animation, anim_type, sprite_frames)
        animations[anim_type] = animation

    return animations

func _create_character_animation(animation: Animation, anim_type: String, frames: SpriteFrames) -> void:
    var track_index = animation.add_track(Animation.TYPE_VALUE)
    animation.track_set_path(track_index, Sprite2D.get_path() + ":frame")

    match anim_type:
        "idle":
            _create_idle_animation(animation, track_index, frames)
        "walk":
            _create_walk_animation(animation, track_index, frames)
        "attack":
            _create_attack_animation(animation, track_index, frames)
```

### çŠ¶æ€æœºç³»ç»Ÿ
```gdscript
# æ™ºèƒ½åŠ¨ç”»çŠ¶æ€æœºç”Ÿæˆå™¨
class_name AnimationStateMachineGenerator extends Node
@export var state_transitions: Dictionary = {}

func create_state_machine(character_name: String) -> AnimationNodeStateMachine:
    var state_machine = AnimationNodeStateMachine.new()

    # åˆ›å»ºåŸºç¡€çŠ¶æ€èŠ‚ç‚¹
    var idle_state = AnimationNodeAnimation.new()
    idle_state.animation = "idle"

    var walk_state = AnimationNodeAnimation.new()
    walk_state.animation = "walk"

    var attack_state = AnimationNodeAnimation.new()
    attack_state.animation = "attack"

    # æ·»åŠ çŠ¶æ€åˆ°çŠ¶æ€æœº
    state_machine.add_node("Idle", idle_state)
    state_machine.add_node("Walk", walk_state)
    state_machine.add_node("Attack", attack_state)

    # åˆ›å»ºçŠ¶æ€è½¬æ¢
    _create_transition(state_machine, "Idle", "Walk", "is_moving")
    _create_transition(state_machine, "Walk", "Idle", "!is_moving")
    _create_transition(state_machine, "Idle", "Attack", "attack_pressed")
    _create_transition(state_machine, "Attack", "Idle", "animation_finished")

    return state_machine
```

## ç²’å­ç‰¹æ•ˆç³»ç»Ÿ

### æ™ºèƒ½ç²’å­ç”Ÿæˆ
```gdscript
# ç²’å­ç‰¹æ•ˆç”Ÿæˆå™¨
class_name ParticleEffectGenerator extends Node

func create_explosion_effect(position: Vector2) -> GPUParticles2D:
    var particles = GPUParticles2D.new()
    particles.position = position
    particles.emitting = true
    particles.one_shot = true

    # é…ç½®ç«ç„°ç²’å­
    var fire_material = create_fire_material()
    particles.process_material = fire_material

    # è®¾ç½®ç²’å­å‚æ•°
    particles.amount = 100
    particles.lifetime = 2.0
    particles.explosiveness = 0.8
    particles.initial_velocity_min = 100.0
    particles.initial_velocity_max = 300.0

    return particles

func create_fire_material() -> ParticleProcessMaterial:
    var material = ParticleProcessMaterial.new()

    # é¢œè‰²æ¸å˜
    var gradient = Gradient.new()
    gradient.add_color_point(0.0, Color.YELLOW)
    gradient.add_color_point(0.5, Color.ORANGE)
    gradient.add_color_point(1.0, Color.RED)

    material.color = gradient
    material.scale_min = 0.1
    material.scale_max = 0.3
    material.scale_random = 0.5

    return material
```

### å¤æ‚ç‰¹æ•ˆç»„åˆ
```gdscript
# å¤šå±‚çº§ç‰¹æ•ˆç³»ç»Ÿ
class_name CompositeEffectSystem extends Node
var effect_layers: Array[GPUParticles2D] = []

func create_magic_spell_effect(cast_position: Vector2, target_position: Vector2) -> Node2D:
    var effect_container = Node2D.new()

    # åˆ›å»ºé­”æ³•è½¨è¿¹
    var trail_particles = create_magic_trail(cast_position, target_position)
    effect_container.add_child(trail_particles)

    # åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
    var explosion_particles = create_magic_explosion(target_position)
    effect_container.add_child(explosion_particles)

    # åˆ›å»ºå…‰ç¯æ•ˆæœ
    var aura_particles = create_magic_aura(target_position)
    effect_container.add_child(aura_particles)

    return effect_container

func create_magic_trail(start: Vector2, end: Vector2) -> GPUParticles2D:
    var trail = GPUParticles2D.new()
    trail.emitting = true

    # é…ç½®è½¨è¿¹ç²’å­
    var trail_material = ParticleProcessMaterial.new()
    trail_material.direction = Vector3(end - start, 0).normalized()
    trail_material.initial_velocity_min = 200.0
    trail_material.initial_velocity_max = 300.0

    # ç´«è‰²é­”æ³•ç²’å­
    var gradient = Gradient.new()
    gradient.add_color_point(0.0, Color.MAGENTA)
    gradient.add_color_point(1.0, Color.PURPLE)
    trail_material.color = gradient

    trail.process_material = trail_material
    return trail
```

## éŸ³æ•ˆé›†æˆç³»ç»Ÿ

### æ™ºèƒ½éŸ³æ•ˆç®¡ç†
```gdscript
# éŸ³æ•ˆç®¡ç†å™¨
class_name AudioManager extends Node
@export var audio_bus_layout: AudioBusLayout

var sound_library: Dictionary = {}
var music_player: AudioStreamPlayer
var sound_players: Array[AudioStreamPlayer]

func _ready() -> void:
    _setup_audio_bus()
    _create_sound_players()
    _load_default_sounds()

func play_sound(sound_name: String, position: Vector2 = Vector2.ZERO) -> void:
    var audio_stream = sound_library.get(sound_name)
    if not audio_stream:
        push_warning("Sound not found: " + sound_name)
        return

    var player = _get_available_player()
    player.stream = audio_stream
    player.play()

    # å¦‚æœæŒ‡å®šäº†ä½ç½®ï¼Œä½¿ç”¨2DéŸ³æ•ˆ
    if position != Vector2.ZERO:
        var audio_player_2d = AudioStreamPlayer2D.new()
        audio_player_2d.stream = audio_stream
        audio_player_2d.global_position = position

        # âœ… æ­£ç¡®ï¼šå®‰å…¨æ£€æŸ¥åœºæ™¯æ ‘å’Œæ·»åŠ èŠ‚ç‚¹
        if get_tree() and get_tree().current_scene:
            get_tree().current_scene.add_child(audio_player_2d)
            audio_player_2d.play()
            await audio_player_2d.finished
            # âœ… æ­£ç¡®ï¼šä½¿ç”¨å»¶è¿Ÿåˆ é™¤é¿å…åœ¨å›è°ƒä¸­ç›´æ¥åˆ é™¤
            audio_player_2d.call_deferred("queue_free")
        else:
            push_warning("åœºæ™¯æ ‘æœªå‡†å¤‡å°±ç»ªï¼Œæ— æ³•æ’­æ”¾2DéŸ³æ•ˆ")

func play_footstep_sound(surface_type: String) -> void:
    var footstep_variants = sound_library.get("footstep_" + surface_type, [])
    if footstep_variants.size() > 0:
        var random_sound = footstep_variants[randi() % footstep_variants.size()]
        play_sound(random_sound)
```

### åŠ¨æ€éŸ³æ•ˆç”Ÿæˆ
```gdscript
# ç¨‹åºåŒ–éŸ³æ•ˆç”Ÿæˆå™¨
class_name ProceduralAudioGenerator extends Node

func generate_laser_sound() -> AudioStream:
    var generator = AudioStreamGenerator.new()
    generator.sample_rate = 44100
    generator.buffer_length = 0.5

    var playback = generator.instantiate_playback()
    var frames_to_fill = int(generator.sample_rate * generator.buffer_length)

    # ç”Ÿæˆæ¿€å…‰éŸ³æ•ˆï¼ˆé¢‘ç‡æ‰«æï¼‰
    for i in range(frames_to_fill):
        var t = float(i) / generator.sample_rate
        var frequency = 800.0 - 400.0 * t  # ä»800Hzæ‰«æåˆ°400Hz
        var amplitude = exp(-t * 3.0)  # æŒ‡æ•°è¡°å‡

        var sample = amplitude * sin(2.0 * PI * frequency * t)
        playback.push_frame(Vector2.ONE * sample)

    return generator

func generate_impact_sound(velocity: float) -> AudioStream:
    var generator = AudioStreamGenerator.new()
    generator.sample_rate = 44100
    generator.buffer_length = 0.2

    var playback = generator.instantiate_playback()
    var frames_to_fill = int(generator.sample_rate * generator.buffer_length)

    # åŸºäºé€Ÿåº¦ç”Ÿæˆå†²å‡»éŸ³æ•ˆ
    var base_frequency = clamp(velocity * 10.0, 100.0, 1000.0)

    for i in range(frames_to_fill):
        var t = float(i) / generator.sample_rate
        var amplitude = exp(-t * 10.0)  # å¿«é€Ÿè¡°å‡
        var frequency = base_frequency + randf_range(-50.0, 50.0)

        var sample = amplitude * (sin(2.0 * PI * frequency * t) + randf_range(-0.1, 0.1))
        playback.push_frame(Vector2.ONE * sample)

    return generator
```

## èµ„æºä¼˜åŒ–ç³»ç»Ÿ

### æ™ºèƒ½å‹ç¼©
```gdscript
# èµ„æºä¼˜åŒ–å™¨
class_name AssetOptimizer extends Node

func optimize_texture(texture: Texture2D, target_size: Vector2) -> Texture2D:
    var image = texture.get_image()

    # è°ƒæ•´å°ºå¯¸
    image.resize(target_size.x, target_size.y, Image.INTERPOLATE_LANCZOS)

    # å‹ç¼©æ ¼å¼
    var compressed_texture = ImageTexture.new()
    compressed_texture.set_image(image)

    return compressed_texture

func optimize_audio(audio_stream: AudioStream) -> AudioStream:
    if audio_stream is AudioStreamMP3:
        # è½¬æ¢ä¸ºOGGæ ¼å¼ä»¥è·å¾—æ›´å¥½çš„å‹ç¼©æ¯”
        var ogg_stream = AudioStreamOggVorbis.new()
        # è½¬æ¢é€»è¾‘...
        return ogg_stream

    return audio_stream
```

### æ‰¹é‡å¤„ç†
```gdscript
# æ‰¹é‡èµ„æºå¤„ç†å™¨
class_name BatchAssetProcessor extends Node

func process_sprite_sheets(input_folder: String, output_folder: String) -> void:
    var dir = DirAccess.open(input_folder)
    if not dir:
        push_error("Cannot open input folder: " + input_folder)
        return

    dir.list_dir_begin()
    var file_name = dir.get_next()

    while file_name != "":
        if file_name.ends_with(".png"):
            var input_path = input_folder + "/" + file_name
            var output_path = output_folder + "/" + file_name.get_basename() + ".tres"

            _process_sprite_sheet(input_path, output_path)

        file_name = dir.get_next()

func _process_sprite_sheet(input_path: String, output_path: String) -> void:
    var texture = load(input_path)
    var sprite_frames = SpriteFrames.new()

    # è‡ªåŠ¨æ£€æµ‹å’Œåˆ‡ç‰‡
    var frame_size = _detect_frame_size(texture)
    _slice_texture(texture, frame_size, sprite_frames)

    # ä¿å­˜èµ„æº
    ResourceSaver.save(sprite_frames, output_path)
```

## æ™ºèƒ½ç‰¹æ€§

### è‡ªåŠ¨åŒ–å·¥ä½œæµ
- **æ‰¹é‡å¤„ç†**ï¼šä¸€é”®å¤„ç†å¤§é‡èµ„æºæ–‡ä»¶
- **æ™ºèƒ½æ£€æµ‹**ï¼šè‡ªåŠ¨æ£€æµ‹ç²¾çµå°ºå¯¸å’ŒåŠ¨ç”»å¸§
- **æ ¼å¼ä¼˜åŒ–**ï¼šè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„èµ„æºæ ¼å¼
- **è´¨é‡å¹³è¡¡**ï¼šåœ¨è´¨é‡å’Œå¤§å°ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡

### AIè¾…åŠ©åˆ¶ä½œ
- **åŠ¨ç”»é¢„æµ‹**ï¼šåŸºäºè§’è‰²ç±»å‹é¢„æµ‹åŠ¨ç”»éœ€æ±‚
- **ç‰¹æ•ˆæ¨è**ï¼šæ ¹æ®åœºæ™¯æ¨èåˆé€‚çš„ç‰¹æ•ˆ
- **éŸ³æ•ˆåŒ¹é…**ï¼šè‡ªåŠ¨åŒ¹é…éŸ³æ•ˆå’Œè§†è§‰æ•ˆæœ
- **é£æ ¼ç»Ÿä¸€**ï¼šç¡®ä¿æ‰€æœ‰èµ„æºé£æ ¼ä¸€è‡´

### å®æ—¶é¢„è§ˆ
- **å³æ—¶é¢„è§ˆ**ï¼šåˆ¶ä½œè¿‡ç¨‹ä¸­å®æ—¶é¢„è§ˆæ•ˆæœ
- **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§èµ„æºå¯¹æ€§èƒ½çš„å½±å“
- **ç‰ˆæœ¬å¯¹æ¯”**ï¼šå¯¹æ¯”ä¸åŒç‰ˆæœ¬çš„æ•ˆæœå·®å¼‚
- **å›¢é˜Ÿåä½œ**ï¼šå¤šäººåä½œåˆ¶ä½œå’Œå®¡æ ¸

## ç¤ºä¾‹å®ç°

### å®Œæ•´è§’è‰²åŠ¨ç”»ç³»ç»Ÿ
```gdscript
# æ™ºèƒ½è§’è‰²åŠ¨ç”»ç³»ç»Ÿ
class_name SmartCharacterAnimationSystem extends Node
@export var character_data: CharacterData

func generate_complete_animation_system() -> Node:
    var animation_container = Node.new()
    animation_container.name = character_data.character_name + "_Animations"

    # åˆ›å»ºç²¾çµå¸§èµ„æº
    var sprite_frames = create_sprite_frames()

    # åˆ›å»ºåŠ¨ç”»æ’­æ”¾å™¨
    var animation_player = create_animation_player(sprite_frames)
    animation_container.add_child(animation_player)

    # åˆ›å»ºåŠ¨ç”»çŠ¶æ€æœº
    var animation_tree = create_animation_tree(sprite_frames)
    animation_container.add_child(animation_tree)

    # åˆ›å»ºéŸ³æ•ˆç®¡ç†
    var audio_manager = create_character_audio_manager()
    animation_container.add_child(audio_manager)

    return animation_container

func create_sprite_frames() -> SpriteFrames:
    var frames = SpriteFrames.new()

    for animation_name in character_data.animations.keys():
        var animation_data = character_data.animations[animation_name]
        _load_animation_frames(frames, animation_name, animation_data)

    return frames
```

## è´¨é‡ä¿è¯

### è§†è§‰è´¨é‡
- **å¸§ç‡ä¸€è‡´æ€§**ï¼šç¡®ä¿åŠ¨ç”»å¸§ç‡ç¨³å®š
- **é¢œè‰²å‡†ç¡®æ€§**ï¼šä¿æŒé¢œè‰²è¿˜åŸå‡†ç¡®
- **è¾¹ç¼˜å¤„ç†**ï¼šä¼˜åŒ–ç²¾çµè¾¹ç¼˜å’ŒæŠ—é”¯é½¿
- **è§†è§‰ä¸€è‡´æ€§**ï¼šç¡®ä¿æ•´ä½“è§†è§‰é£æ ¼ç»Ÿä¸€

### æŠ€æœ¯è´¨é‡
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–èµ„æºåŠ è½½å’Œè¿è¡Œæ€§èƒ½
- **å†…å­˜ç®¡ç†**ï¼šåˆç†æ§åˆ¶å†…å­˜ä½¿ç”¨
- **å…¼å®¹æ€§**ï¼šç¡®ä¿è·¨å¹³å°å…¼å®¹æ€§
- **å¯æ‰©å±•æ€§**ï¼šä¾¿äºåç»­æ·»åŠ æ–°èµ„æº

### ç”¨æˆ·ä½“éªŒ
- **åŠ è½½é€Ÿåº¦**ï¼šä¼˜åŒ–èµ„æºåŠ è½½æ—¶é—´
- **æµç•…åº¦**ï¼šç¡®ä¿åŠ¨ç”»å’Œç‰¹æ•ˆæµç•…
- **éŸ³ç”»åŒæ­¥**ï¼šç²¾ç¡®çš„éŸ³ç”»åŒæ­¥
- **å“åº”é€Ÿåº¦**ï¼šå¿«é€Ÿçš„äº¤äº’å“åº”

## ä½¿ç”¨é™åˆ¶å’Œæ³¨æ„äº‹é¡¹

### æŠ€æœ¯é™åˆ¶
- **æ–‡ä»¶å¤§å°**ï¼šå¤§å‹èµ„æºæ–‡ä»¶å¯èƒ½å½±å“æ€§èƒ½
- **æ ¼å¼æ”¯æŒ**ï¼šæŸäº›ç‰¹æ®Šæ ¼å¼å¯èƒ½ä¸å…¼å®¹
- **ç¡¬ä»¶è¦æ±‚**ï¼šå¤æ‚ç‰¹æ•ˆéœ€è¦è¾ƒé«˜ç¡¬ä»¶é…ç½®

### æœ€ä½³å®è·µ
- **èµ„æºä¼˜åŒ–**ï¼šå®šæœŸä¼˜åŒ–å’Œå‹ç¼©èµ„æº
- **å¤‡ä»½ç®¡ç†**ï¼šåšå¥½èµ„æºæ–‡ä»¶çš„å¤‡ä»½
- **ç‰ˆæœ¬æ§åˆ¶**ï¼šä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶ç®¡ç†èµ„æº

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜
1. **åŠ¨ç”»å¡é¡¿**ï¼šæ£€æŸ¥å¸§ç‡å’Œèµ„æºå¤§å°
2. **ç‰¹æ•ˆä¸æ˜¾ç¤º**ï¼šéªŒè¯ç²’å­ç³»ç»Ÿé…ç½®
3. **éŸ³æ•ˆæ’­æ”¾å¤±è´¥**ï¼šæ£€æŸ¥éŸ³é¢‘æ–‡ä»¶æ ¼å¼
4. **èµ„æºåŠ è½½æ…¢**ï¼šä¼˜åŒ–èµ„æºå¤§å°å’Œæ ¼å¼

### è°ƒè¯•æŠ€å·§
- ä½¿ç”¨Godotçš„è°ƒè¯•å·¥å…·
- æ£€æŸ¥æ§åˆ¶å°é”™è¯¯ä¿¡æ¯
- ç›‘æ§æ€§èƒ½æŒ‡æ ‡
- é€æ­¥æ’é™¤æ•…éšœ

## æ›´æ–°æ—¥å¿—

### v1.0.0 (å½“å‰ç‰ˆæœ¬)
- åŸºç¡€åŠ¨ç”»åˆ¶ä½œåŠŸèƒ½
- ç²’å­ç‰¹æ•ˆç³»ç»Ÿ
- éŸ³æ•ˆé›†æˆåŠŸèƒ½
- èµ„æºä¼˜åŒ–å·¥å…·

### è®¡åˆ’åŠŸèƒ½
- AIåŠ¨ç”»ç”Ÿæˆ
- å®æ—¶åä½œåˆ¶ä½œ
- æ›´å¤šç‰¹æ•ˆæ¨¡æ¿
- é«˜çº§éŸ³æ•ˆå¤„ç†

## Camera2Dä¸åŠ¨ç”»ç³»ç»Ÿé›†æˆæœ€ä½³å®è·µ

### ğŸ¬ è§’è‰²æ˜¾ç¤ºé—®é¢˜è¯Šæ–­ç³»ç»Ÿ
```gdscript
# è§’è‰²å¯è§æ€§è¯Šæ–­å™¨ - è§£å†³è§’è‰²çœ‹ä¸åˆ°çš„é—®é¢˜
class_name CharacterVisibilityDiagnostic extends Node

@export var character: AnimatedSprite2D
@export var camera: Camera2D
@export var diagnostic_enabled: bool = true

func run_diagnostic_check() -> void:
    print("=== è§’è‰²å¯è§æ€§è¯Šæ–­å¼€å§‹ ===")

    # 1. æ£€æŸ¥AnimatedSprite2Dé…ç½®
    _check_animated_sprite_configuration()

    # 2. æ£€æŸ¥SpriteFramesèµ„æº
    _check_sprite_frames_resource()

    # 3. æ£€æŸ¥ç›¸æœºé…ç½®
    _check_camera_configuration()

    # 4. æ£€æŸ¥ä¸–ç•Œåæ ‡å’Œè§†é‡å…³ç³»
    _check_world_coordinates()

    print("=== è§’è‰²å¯è§æ€§è¯Šæ–­å®Œæˆ ===")

func _check_animated_sprite_configuration() -> void:
    if not character:
        print("âŒ é”™è¯¯: AnimatedSprite2Då¼•ç”¨ä¸ºç©º")
        return

    print("âœ… AnimatedSprite2Dé…ç½®æ­£å¸¸")
    print("   - ä½ç½®:", character.global_position)
    print("   - å¯è§æ€§:", character.visible)

    if character.sprite_frames:
        print("âœ… SpriteFramesèµ„æºå·²åŠ è½½")
        print("   - å¯ç”¨åŠ¨ç”»:", character.sprite_frames.get_animation_names())
    else:
        print("âŒ é”™è¯¯: SpriteFramesèµ„æºä¸ºç©º")

func _check_camera_configuration() -> void:
    if not camera:
        print("âŒ é”™è¯¯: Camera2Då¼•ç”¨ä¸ºç©º")
        return

    print("âœ… Camera2Dé…ç½®æ­£å¸¸")
    print("   - ä½ç½®:", camera.global_position)
    print("   - ç¼©æ”¾:", camera.zoom)
    print("   - å¹³æ»‘è·Ÿéš:", camera.position_smoothing_enabled)
```

### ğŸ“· æ™ºèƒ½ç›¸æœºè·Ÿéšç³»ç»Ÿ
```gdscript
# åŠ¨ç”»é©±åŠ¨çš„ç›¸æœºç³»ç»Ÿ
class_name AnimationDrivenCameraSystem extends Node
@export var target_character: AnimatedSprite2D
@export var camera: Camera2D
@export var follow_speed: float = 5.0

# åŠ¨ç”»çŠ¶æ€å¯¹åº”çš„ç›¸æœºå‚æ•°
var animation_camera_settings = {
    "idle": {"zoom": Vector2(1.0, 1.0), "offset": Vector2(0, -80)},
    "walk": {"zoom": Vector2(1.1, 1.1), "offset": Vector2(0, -90)},
    "attack": {"zoom": Vector2(1.2, 1.2), "offset": Vector2(0, -70)}
}

func _process(delta):
    if target_character and camera:
        _update_camera_follow(delta)

func _update_camera_follow(delta: float) -> void:
    var current_anim = target_character.animation
    var settings = animation_camera_settings.get(current_anim, animation_camera_settings["idle"])

    # å¹³æ»‘è·Ÿéš
    var target_position = target_character.global_position + settings.offset
    camera.global_position = camera.global_position.lerp(target_position, follow_speed * delta)
    camera.zoom = camera.zoom.lerp(settings.zoom, follow_speed * delta * 0.5)
```

### ğŸ› ï¸ å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ

#### é—®é¢˜1: è§’è‰²æ‰è½åˆ°å±å¹•å¤–
```gdscript
# ä¿®å¤è§’è‰²ç‰©ç†å’Œä½ç½®
func fix_character_physics(character: CharacterBody2D):
    # è®¾ç½®åˆç†çš„åˆå§‹ä½ç½®
    character.position = Vector2(character.position.x, 145)  # åœ°é¢ä»¥ä¸Š

    # é…ç½®ç‰©ç†å‚æ•°
    if character.has_method("set_gravity_scale"):
        character.set_gravity_scale(1.0)

    # ç¡®ä¿å¯ç”¨ç¢°æ’
    character.set_collision_layer_value(1, true)
    character.set_collision_mask_value(1, true)
```

#### é—®é¢˜2: ç›¸æœºä¸è·Ÿéšè§’è‰²
```gdscript
# ä¿®å¤ç›¸æœºè·Ÿéš
func fix_camera_follow(camera: Camera2D, target: Node2D):
    camera.position_smoothing_enabled = true
    camera.position_smoothing_speed = 5.0

    # è®¾ç½®ç›¸æœºè¾¹ç•Œ
    camera.limit_left = -1024
    camera.limit_right = 1024
    camera.limit_top = -600
    camera.limit_bottom = 600
```

#### é—®é¢˜3: SpriteFramesèµ„æºç¼ºå¤±
```gdscript
# ä¿®å¤SpriteFramesèµ„æº
func fix_sprite_frames(character: AnimatedSprite2D):
    if not character.sprite_frames:
        # åˆ›å»ºé»˜è®¤SpriteFrames
        var frames = SpriteFrames.new()

        # æ·»åŠ åŸºæœ¬åŠ¨ç”»
        _add_default_animations(frames)

        character.sprite_frames = frames

func _add_default_animations(frames: SpriteFrames):
    # ä½¿ç”¨é¢œè‰²å—ä½œä¸ºå ä½ç¬¦çº¹ç†
    var placeholder_texture = _create_colored_texture(Color.RED, Vector2(64, 64))

    # æ·»åŠ idleåŠ¨ç”»
    frames.add_animation("idle")
    frames.add_frame("idle", placeholder_texture)

    # æ·»åŠ walkåŠ¨ç”»
    frames.add_animation("walk")
    frames.add_frame("walk", placeholder_texture)
    frames.add_frame("walk", placeholder_texture)

func _create_colored_texture(color: Color, size: Vector2) -> ImageTexture:
    var image = Image.create(size.x, size.y, false, Image.FORMAT_RGB8)
    image.fill(color)
    var texture = ImageTexture.new()
    texture.set_image(image)
    return texture
```

### ğŸ¯ è°ƒè¯•å·¥å…·
```gdscript
# å®æ—¶è°ƒè¯•æ˜¾ç¤º
class_name AnimationDebugDisplay extends Control
@export var character: AnimatedSprite2D
@export var camera: Camera2D

func _process(delta):
    queue_redraw()

func _draw():
    if not character or not camera:
        return

    # ç»˜åˆ¶è§’è‰²è¾¹ç•Œæ¡†
    var char_rect = Rect2(character.global_position - camera.global_position + size/2,
                          character.sprite_frames.get_frame_texture(character.animation, 0).get_size())
    draw_rect(char_rect, Color.GREEN, false, 2.0)

    # ç»˜åˆ¶ç›¸æœºè§†é‡ä¸­å¿ƒ
    var center = size / 2
    draw_circle(center, 5.0, Color.RED)

    # æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
    var debug_text = "è§’è‰²: %s\nä½ç½®: %s\nåŠ¨ç”»: %s\nç›¸æœº: %s" % [
        character.name,
        character.global_position,
        character.animation,
        camera.global_position
    ]
    draw_string(ThemeDB.fallback_font, Vector2(10, 30), debug_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 16, Color.WHITE)
```

---

**æŠ€èƒ½çŠ¶æ€**: âœ… å¯ç”¨
**æœ€åæ›´æ–°**: 2025-11-09
**å…¼å®¹æ€§**: Godot 4.5+
**æ–°å¢åŠŸèƒ½**: Camera2Dé›†æˆã€è§’è‰²æ˜¾ç¤ºé—®é¢˜è¯Šæ–­
**ä¾èµ–**: Godot MCP å·¥å…·é›† + åŠ¨ç”»åˆ¶ä½œçŸ¥è¯†